<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!--
      This file contains targets to integrate SonarQube and MSBuild.
      
      The targets will produce an output folder structure containing information required
      by SonarQube.
      
      A subdirectory will be created for each MSBuild project. Information about the project 
	  will be written to a file called "ProjectInfo.xml". Additional files may also be written
	  containing information required by different analysers e.g. if there are managed code files
	  then a file called "ManagedFileList" will be written containing the list of managed code
	  files that was passed to the compiler.
      
      The output will only be produced if the property $(SonarOutputPath) is specified. $(SonarOutputPath) is
      the output directory in which the output file should be dropped and can be relative or
      absolute (use an absolute path if you want a consolidated set of output for a single build).

      Using this targets file
      - - - - - - - - - - - -
      To use these targets with a single project, import the targets into that project.

      To use these targets with all projects, put the file in:
          C:\Program Files (x86)\MSBuild\12.0\Microsoft.Common.Targets\ImportBefore
      ... adjusting the MSBuild version as necessary.


      Example of use:
      - - - - - - - -
      msbuild MyProject.csproj /p:SonarOutputPath=C:\SonarOutput


      Excluding projects and files from SonarQube analysis
      ****************************************************
      Individual projects can excluded from Sonary analysis by setting
      the property $(SonarExclude) e.g.
      
        <SonarExclude>true</SonarExclude>

      Individual files can be excluded from analysis by setting the 
      <SonarExclude> metadata item e.g.
      
        <Compile Include="Logger.cs">
          <SonarExclude>true</SonarExclude>
        </Compile>
  
  
      Test projects
      *************
      The analysis performed by SonarQube varies depending on whether a project
      is a test project or not.

      A project can be explicitly marked as being a test or product project by setting
      the property $(SonarTestProject) e.g.
      
        <SonarTestProject>true</SonarTestProject>
       
      If the $(SonarTestProject) is not set then the targets will determine the project
      type as follows:
      
      1) Projects whose full project file name matches the regular expression in the property
          $(SonarTestProjectNameRegex) will be treated as test projects.
          By default, any projects with:
					* "test" (case-insensitive) in the project name, or
					* that have a directory called "test" or "tests" in the path
					will be treated as test projects
					
					Note that the regular expression uses the .Net Regex format i.e. "+" is the
					single character wildcard and "*" is the multi-character wildcard (zero to many).
          
      2) MSTest projects will be treated as test projects.
          The $(ProjectTypeGuid) of MS Test projects contains a specific guid
          ("3AC096D0-A1C2-E12C-1390-A8335801FDAB")
  
-->

  <!-- Safeguard against importing this .targets file multiple times -->
  <PropertyGroup>
    <SonarImported>true</SonarImported>
  </PropertyGroup>

  <!-- Set defaults for the SonarQube paths if explicit values have not been provided -->
  <PropertyGroup Condition="$(RunSonarAnalysis) == 'true' ">
    <!-- Use the TeamBuild per-build base directory as a root -->
    <SonarTempPath Condition=" $(SonarTempPath) == '' AND $(TF_BUILD_BUILDDIRECTORY) != '' "
                   >$(TF_BUILD_BUILDDIRECTORY)\SonarTemp</SonarTempPath>

    <SonarConfigPath Condition="$(SonarConfigPath) == '' AND $(SonarTempPath) !='' "
                     >$(SonarTempPath)\Config\</SonarConfigPath>

    <SonarOutputPath Condition="$(SonarOutputPath) == '' AND $(SonarTempPath) !='' "
                     >$(SonarTempPath)\Output\</SonarOutputPath>
  
  </PropertyGroup>
  
  <!-- **************************************************************************** -->
  <!-- Using tasks -->
  <!-- **************************************************************************** -->
  <PropertyGroup Condition="$(RunSonarAnalysis) == 'true' ">
    <!-- Assume that the tasks assembly is in the same location as this targets file 
				 or in a parent directory unless another location has already been specified. -->
    <SonarBuildTasksAssemblyFile Condition=" $(SonarBuildTasksAssemblyFile) == '' ">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), Sonar.MSBuild.Tasks.dll))\Sonar.MSBuild.Tasks.dll</SonarBuildTasksAssemblyFile>
  </PropertyGroup>

  <UsingTask TaskName="WriteProjectInfoFile" AssemblyFile="$(SonarBuildTasksAssemblyFile)" />


  <!-- **************************************************************************** -->
  <!-- **************************************************************************** -->
  <!-- Targets -->
  <!-- **************************************************************************** -->
  <!-- **************************************************************************** -->

  <Target Name="SkippingSonarAnalysis" AfterTargets="CoreCompile"
          Condition="$(RunSonarAnalysis) == 'true' AND $(SonarOutputPath) == '' ">
    <Message Importance="high" Text="Skipping dumping compile outputs because SonarOutputPath has not been specified" />
  </Target>

  <!-- **************************************************************************** -->
  <!-- Write the project info file for the current project.
       Any targets which affect @(AnalysisResults) should be run before this target,
       otherwise those results will not appear in the project info file.
  -->
  <!-- **************************************************************************** -->
  <Target Name="ExecuteSonarProcessing" AfterTargets="CoreCompile"
        Condition="$(RunSonarAnalysis) == 'true' AND  $(SonarOutputPath) != '' ">

    <Message Importance="normal" Condition=" $(SonarExclude) == 'true' "
             Text="Skipping SonarQube analysis: SonarExclude is set to true" />

    <CallTarget Targets="WriteSonarProjectData" Condition=" $(SonarExclude) != 'true' " />

  </Target>
  
  <Target Name="WriteSonarProjectData" >
    
    <Error Condition=" $(SonarExclude) == 'true' " Text="Should not be executing WriteSonarProjectData when (SonarExclude) is true" />
    
    <!-- Calculate a project-specific folder name -->
    <PropertyGroup>
      <FolderDisambiguator>$(ProjectGuid)</FolderDisambiguator>
      <FolderDisambiguator Condition=" $(FolderDisambiguator)=='' ">$([System.Guid]::NewGuid())</FolderDisambiguator>
      <ProjectSpecificDir>$(SonarOutputPath)\$(MSBuildProjectName)_$(FolderDisambiguator)</ProjectSpecificDir>
    </PropertyGroup>

    <!-- Ensure the contents file doesn't already exist -->
    <Delete Files="$(ProjectSpecificDir)\CompileList.txt" />

    <!-- Create the project-specific output folder -->
    <RemoveDir Directories="$(ProjectSpecificDir)" />
    <MakeDir Directories="$(ProjectSpecificDir)" />

    <ItemGroup>
      <!-- Calculate the sets of files to write out to the file lists.
           Exclude any that have the metadata 'SonarExclude' set. -->
      <SonarManagedFiles Include="@(Compile)" Condition=" %(Compile.SonarExclude) != 'true' " />
      <!-- Add any files that are in the gruop T4Transform -->
      <SonarContentFiles Include="@(Content)" Condition=" %(Content.SonarExclude) != 'true' "/>

    </ItemGroup>

    <PropertyGroup>
      <!-- Work out which types of input files exist-->
      <ManagedFilesExist Condition=" @(SonarManagedFiles) != '' ">true</ManagedFilesExist>
      <ContentFilesExist Condition=" @(SonarContentFiles) != '' ">true</ContentFilesExist>

      <!-- Set the file names for the list files -->
      <ManagedFileList>$(ProjectSpecificDir)\ManagedSourceFiles.txt</ManagedFileList>	
      <ContentFileList>$(ProjectSpecificDir)\ContentFiles.txt</ContentFileList>
    </PropertyGroup>

    <!-- Write out a list of managed files that will be passed to the compiler -->
    <WriteLinesToFile Condition=" $(ManagedFilesExist) == 'true' "
            File="$(ManagedFileList)"
            Lines="%(SonarManagedFiles.FullPath)"
            Overwrite="false"
            Encoding="Unicode"/>

    <!-- Record the list of managed source files as an analysis result -->
    <ItemGroup Condition=" $(ManagedFilesExist) == 'true' ">
      <AnalysisResults Include="$(ManagedFileList)">
        <Id>ManagedCompilerInputs</Id>
      </AnalysisResults>
    </ItemGroup>

    <!-- Write out a list of content files that will be passed to the compiler -->
    <WriteLinesToFile Condition=" $(ContentFilesExist) == 'true' "
            File="$(ContentFileList)"
            Lines="%(SonarContentFiles.FullPath)"
            Overwrite="false"
            Encoding="Unicode"/>
    
    <!-- Record the list of content files as an analysis result -->
    <ItemGroup Condition=" $(ContentFilesExist) == 'true' ">
      <AnalysisResults Include="$(ContentFileList)">
        <Id>ContentFiles</Id>
      </AnalysisResults>
    </ItemGroup>

    <PropertyGroup>
    </PropertyGroup>

    <!-- Work out if the project is a test project or not -->
    <!-- If it is explicitly marked then use that value, otherwise:
          * check if the name matches the regular expression, or
          * check if it has one of the expected project types guids.
         If either is true then the project is a test project, otherwise
         it is a product project.
    -->
    <PropertyGroup Condition=" $(SonarTestProject) == '' ">
      <!-- The MS Test project type guid-->
      <SonarMsTestProjectTypeGuid>3AC096D0-A1C2-E12C-1390-A8335801FDAB</SonarMsTestProjectTypeGuid>

      <!-- Default SonarQube test project regular expression -->
      <!-- NOTE: this uses .NET regular expression syntax -->
			<!-- Matches: any project under a "\test\" or "\tests" directory, or that has "test" in the file name" -->
      <SonarTestProjectNameRegex Condition=" $(SonarTestProjectNameRegex) == '' ">(.*\\tests?\\.*)|(\.*test[^\\]*$)</SonarTestProjectNameRegex>

      <SonarTestProject Condition=" $(SonarTestProjectNameRegex) != '' AND
                        $([System.Text.RegularExpressions.Regex]::IsMatch($(MSBuildProjectFullPath), $(SonarTestProjectNameRegex), System.Text.RegularExpressions.RegexOptions.IgnoreCase)) ">true</SonarTestProject>

      <SonarTestProject Condition=" $(SonarTestProject) == '' AND $(ProjectTypeGuid.ToUpperInvariant().Contains('$(SonarMsTestProjectTypeGuid)')) ">true</SonarTestProject>
      
      <SonarTestProject Condition=" $(SonarTestProject) == '' ">false</SonarTestProject>
    </PropertyGroup>

    <Message Importance="low" Condition=" $(SonarTestProject) == 'true' "
             Text="SonarQube: project will be treated as a test project : $(MSBuildProjectName)" />
    
    <WriteProjectInfoFile ProjectName="$(MSBuildProjectName)"
       FullProjectPath="$(MSBuildProjectFullPath)"
       ProjectGuid="$(ProjectGuid)"
       IsTest="$(SonarTestProject)"
       AnalysisResults="@(AnalysisResults)"
       OutputFolder="$(ProjectSpecificDir)" />
  </Target>


  <!-- **************************************************************************** -->
  <!-- FxCop -->
  <!-- **************************************************************************** -->
  <!-- We want to control whether or FxCop analysis is run or not, and we want to control
       the ruleset that is used.
       
       There may/may not be individual FxCop settings in each project, and the TeamBuild
       definition may also specify whether FxCop is to be run or not (the options being
       "As configured", "Always", and "Never". 
       
       We need to make sure the FxCop targets get loaded if we want to run FxCop, and then
       we need to override any other settings that may exist.
       
       We ensure the FxCop targets are loaded by setting the $(RunCodeAnalysisOnce).
       We then override any FxCop property settings by executing a target to programmatically
       update the property values. These values set in this way will take precedence over
       any values passed on the MSBuild command line or in <PropertyGroups>.
       -->
  
  
  <!-- The FxCop targets are conditionally imported so we need to make sure the required condition
       is true early enough. -->
  <PropertyGroup Condition="$(RunSonarAnalysis) == 'true' AND $(SonarOutputPath) != '' ">
    <SonarRulesetFileName Condition=" $(SonarRulesetFileName) == ''">SonarAnalysis.ruleset</SonarRulesetFileName>
    <SonarRulesetFullName>$(SonarConfigPath)\$(SonarRulesetFileName)</SonarRulesetFullName>

    <!-- If the config path hasn't been specified then don't run code analysis-->
    <SonarRulesetExists Condition=" $(SonarConfigPath) == '' ">false</SonarRulesetExists>
    <SonarRulesetExists Condition=" $(SonarConfigPath) != '' ">$([System.IO.File]::Exists($(SonarRulesetFullName)))</SonarRulesetExists>

    <!-- If we are running a SonarQube analysis build then whether or not FxCop is run depends entirely on whether
         the SonarQube ruleset exists. -->
    <RunCodeAnalysisOnce>$(SonarRulesetExists)</RunCodeAnalysisOnce>
  </PropertyGroup>

  <!-- We want to override any properties that have been set declaratively in the project -->
  <Target Name="OverrideCodeAnalysisProperties" Condition="$(RunSonarAnalysis) == 'true' AND $(SonarOutputPath) != '' "
              BeforeTargets="RunCodeAnalysis" >

    <Message Condition="$(SonarRulesetExists) != 'true' "
             Importance="normal"
             Text="Skipping FxCop analysis because the SonarQube ruleset does not exist. Ruleset: $(SonarRulesetFullName)" />

    <Message Condition="$(SonarRulesetExists) == 'true' "
             Importance="normal"
             Text="Running FxCop analysis using the SonarQube ruleset. Ruleset: $(SonarRulesetFullName)" />

    <PropertyGroup>
      <!-- By the time this target is evaluated, the FxCop targets have evaluated the
           $(RunCodeAnalysis) and $(RunCodeAnalysisOnce) properties and used them to 
           set $(RunCodeAnalysisOnThisProject). If we want to stop code analysis from
           running at this point, we need to set $(RunCodeAnalysisOnThisProject). -->
      <RunCodeAnalysisOnThisProject>$(SonarRulesetExists)</RunCodeAnalysisOnThisProject>

      <CodeAnalysisRuleSet>$(SonarRulesetFullName)</CodeAnalysisRuleSet>
      <CodeAnalysisForceOutput>true</CodeAnalysisForceOutput>
      <CodeAnalysisGenerateSuccessFile>true</CodeAnalysisGenerateSuccessFile>
      <CodeAnalysisIgnoreGeneratedCode>true</CodeAnalysisIgnoreGeneratedCode>
    </PropertyGroup>

  </Target>

  <!-- If FxCop is being run then record the FxCop output file as an analysis result -->
  <Target Name="SetFxCopAnalysisResult" Condition=" $(SonarRulesetExists) == 'true' "
                AfterTargets="RunCodeAnalysis" BeforeTargets="WriteSonarProjectData" >
    <ItemGroup>
      <AnalysisResults Include="$(CodeAnalysisLogFile)">
        <Id>FxCop</Id>
      </AnalysisResults>
    </ItemGroup>
  </Target>

  <!-- **************************************************************************** -->
  <!-- End of FxCop section-->
  <!-- **************************************************************************** -->

</Project>