<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!--
      This file contains targets to integrate SonarQube and MSBuild.
      
      The targets will produce an output folder structure containing information required
      by SonarQube.
      
      A subdirectory will be created for each MSBuild project. 
      The list of compiled files for that project will be written to the output file "CompileList.txt".
      Information about project will be written to a file "ProjectInfo.xml".
      
      The output will only be produced if the property $(SonarOutputPath) is specified. $(SonarOutputPath) is
      the output directory in which the output file should be dropped and can be relative or
      absolute (use an absolute path if you want a consolidated set of output for a single build).

      Using this targets file
      - - - - - - - - - - - -
      To use these targets with a single project, import the targets into that project.

      To use these targets with all projects, put the file in:
          C:\Program Files (x86)\MSBuild\12.0\Microsoft.Common.Targets\ImportAfter
      ... adjusting the MSBuild version as necessary.


      Example of use:
      - - - - - - - -
      msbuild MyProject.csproj /p:SonarOutputPath=C:\SonarOutput

-->

  <!-- Safeguard against importing this .targets file multiple times -->
  <PropertyGroup>
    <SonarImported>true</SonarImported>
  </PropertyGroup>

  <!-- Set defaults for the Sonar paths if explicit values have not been provided -->
  <PropertyGroup Condition="$(RunSonarAnalysis) == 'true' ">
    <!-- Use the TeamBuild per-build base directory as a root -->
    <SonarTempPath Condition=" $(SonarTempPath) == '' AND $(TF_BUILD_BUILDDIRECTORY) != '' "
                   >$(TF_BUILD_BUILDDIRECTORY)\SonarTemp</SonarTempPath>

    <SonarConfigPath Condition="$(SonarConfigPath) == '' AND $(SonarTempPath) !='' "
                     >$(SonarTempPath)\Config\</SonarConfigPath>

    <SonarOutputPath Condition="$(SonarOutputPath) == '' AND $(SonarTempPath) !='' "
                     >$(SonarTempPath)\Output\</SonarOutputPath>
  
  </PropertyGroup>
  
  <!-- **************************************************************************** -->
  <!-- Using tasks -->
  <!-- **************************************************************************** -->
  <PropertyGroup Condition="$(RunSonarAnalysis) == 'true' ">
    <!-- Assume that the tasks assembly is in the same location as this targets file unless 
         another location has already been specified. -->
    <SonarBuildTasksAssemblyFile Condition=" $(SonarBuildTasksAssemblyFile) == '' ">$(MSBuildThisFileDirectory)\Sonar.MSBuild.Tasks.dll</SonarBuildTasksAssemblyFile>
  </PropertyGroup>

  <UsingTask TaskName="WriteProjectInfoFile" AssemblyFile="$(SonarBuildTasksAssemblyFile)" />


  <!-- **************************************************************************** -->
  <!-- **************************************************************************** -->
  <!-- Targets -->
  <!-- **************************************************************************** -->
  <!-- **************************************************************************** -->

  <Target Name="SkippingSonarAnalysis" AfterTargets="CoreCompile"
          Condition="$(RunSonarAnalysis) == 'true' AND $(SonarOutputPath) == '' ">
    <Message Importance="high" Text="Skipping dumping compile outputs because SonarOutputPath has not been specified" />
  </Target>

  <!-- **************************************************************************** -->
  <!-- Write the project info file for the current project.
       Any targets which affect @(AnalysisResults) should be run before this target,
       otherwise those results will not appear in the project info file.
  -->
  <!-- **************************************************************************** -->
  <Target Name="WriteSonarProjectData" AfterTargets="CoreCompile"
          Condition="$(RunSonarAnalysis) == 'true' AND  $(SonarOutputPath) != '' ">

    <!-- Calculate a project-specific folder name -->
    <PropertyGroup>
      <FolderDisambiguator>$(ProjectGuid)</FolderDisambiguator>
      <FolderDisambiguator Condition=" $(FolderDisambiguator)=='' ">$([System.Guid]::NewGuid())</FolderDisambiguator>
      <ProjectSpecificDir>$(SonarOutputPath)\$(MSBuildProjectName)_$(FolderDisambiguator)</ProjectSpecificDir>
    </PropertyGroup>

    <!-- Ensure the contents file doesn't already exist -->
    <Delete Files="$(ProjectSpecificDir)\CompileList.txt" />

    <!-- Create the project-specific output folder -->
    <RemoveDir Directories="$(ProjectSpecificDir)" />
    <MakeDir Directories="$(ProjectSpecificDir)" />

		<ItemGroup>
			<!-- Calculate the sets of files to write out to the file lists.
			     Exclude any that have the metadata 'SonarExclude' set. -->
			<SonarManagedFiles Include="@(Compile)" Condition=" %(Compile.SonarExclude) != 'true' " />
			<!-- Add any files that are in the gruop T4Transform -->
			<SonarContentFiles Include="@(Content)" Condition=" %(Content.SonarExclude) != 'true' "/>

		</ItemGroup>

		<PropertyGroup>
			<!-- Work out which types of input files exist-->
			<ManagedFilesExist Condition=" @(SonarManagedFiles) != '' ">true</ManagedFilesExist>
			<ContentFilesExist Condition=" @(SonarContentFiles) != '' ">true</ContentFilesExist>

			<!-- Set the file names for the list files -->
			<ManagedFileList>$(ProjectSpecificDir)\ManagedSourceFiles.txt</ManagedFileList>	
		  <ContentFileList>$(ProjectSpecificDir)\ContentFiles.txt</ContentFileList>
		</PropertyGroup>

		<!-- Write out a list of managed files that will be passed to the compiler -->
    <WriteLinesToFile Condition=" $(ManagedFilesExist) == 'true' "
            File="$(ManagedFileList)"
            Lines="%(SonarManagedFiles.FullPath)"
            Overwrite="false"
            Encoding="Unicode"/>

    <!-- Record the list of managed source files as an analysis result -->
    <ItemGroup Condition=" $(ManagedFilesExist) == 'true' ">
      <AnalysisResults Include="$(ManagedFileList)">
        <Id>ManagedCompilerInputs</Id>
      </AnalysisResults>
    </ItemGroup>

		<!-- Write out a list of content files that will be passed to the compiler -->
    <WriteLinesToFile Condition=" $(ContentFilesExist) == 'true' "
            File="$(ContentFileList)"
            Lines="%(SonarContentFiles.FullPath)"
            Overwrite="false"
            Encoding="Unicode"/>
		
    <!-- Record the list of content files as an analysis result -->
    <ItemGroup Condition=" $(ContentFilesExist) == 'true' ">
      <AnalysisResults Include="$(ContentFileList)">
        <Id>ContentFiles</Id>
      </AnalysisResults>
    </ItemGroup>

		<PropertyGroup>
		</PropertyGroup>

		<!-- Work out if the project is a test project or not -->
		<!-- If it is explicitly marked then use that value, otherwise:
					* check if the name matches the regular expression, or
					* check if it has one of the expected project types guids.
				 If either is true then the project is a test project, otherwise
				 it is a product project.
		-->
		<PropertyGroup Condition=" $(SonarTestProject) == '' ">
			<!-- The MS Test project type guid-->
			<SonarMsTestProjectTypeGuid>3AC096D0-A1C2-E12C-1390-A8335801FDAB</SonarMsTestProjectTypeGuid>

			<!-- Default Sonar test project regular expression -->
			<!-- NOTE: this uses .NET regular expression syntax -->
			<SonarTestProjectNameRegex Condition=" $(SonarTestProjectNameRegex) == '' ">.*test.*</SonarTestProjectNameRegex>

			<SonarTestProject Condition=" $(SonarTestProjectNameRegex) != '' AND
												$([System.Text.RegularExpressions.Regex]::IsMatch($(MsBuildProjectName), $(SonarTestProjectNameRegex), System.Text.RegularExpressions.RegexOptions.IgnoreCase)) ">true</SonarTestProject>

			<SonarTestProject Condition=" $(SonarTestProject) == '' AND $(ProjectTypeGuid.ToUpperInvariant().Contains('$(SonarMsTestProjectTypeGuid)')) ">true</SonarTestProject>
			
			<SonarTestProject Condition=" $(SonarTestProject) == '' ">false</SonarTestProject>
		</PropertyGroup>
		
    <WriteProjectInfoFile ProjectName="$(MSBuildProjectName)"
       FullProjectPath="$(MSBuildProjectFullPath)"
       ProjectGuid="$(ProjectGuid)"
       IsTest="$(SonarTestProject)"
       AnalysisResults="@(AnalysisResults)"
       OutputFolder="$(ProjectSpecificDir)" />
  </Target>


  <!-- **************************************************************************** -->
  <!-- FxCop -->
  <!-- **************************************************************************** -->
  <!-- We want to control whether or FxCop analysis is run or not, and we want to control
       the ruleset that is used.
       
       There may/may not be individual FxCop settings in each project, and the TeamBuild
       definition may also specify whether FxCop is to be run or not (the options being
       "As configured", "Always", and "Never". 
       
       We need to make sure the FxCop targets get loaded if we want to run FxCop, and then
       we need to override any other settings that may exist.
       
       We ensure the FxCop targets are loaded by setting the $(RunCodeAnalysisOnce).
       We then override any FxCop property settings by executing a target to programmatically
       update the property values. These values set in this way will take precedence over
       any values passed on the MSBuild command line or in <PropertyGroups>.
       -->
  
  
  <!-- The FxCop targets are conditionally imported so we need to make sure the required condition
       is true early enough. -->
  <PropertyGroup Condition="$(RunSonarAnalysis) == 'true' AND $(SonarOutputPath) != '' ">
    <SonarRulesetFileName Condition=" $(SonarRulesetFileName) == ''">SonarAnalysis.ruleset</SonarRulesetFileName>
    <SonarRulesetFullName>$(SonarConfigPath)\$(SonarRulesetFileName)</SonarRulesetFullName>

    <!-- If the config path hasn't been specified then don't run code analysis-->
    <SonarRulesetExists Condition=" $(SonarConfigPath) == '' ">false</SonarRulesetExists>
    <SonarRulesetExists Condition=" $(SonarConfigPath) != '' ">$([System.IO.File]::Exists($(SonarRulesetFullName)))</SonarRulesetExists>

    <!-- If we are running a Sonar analysis build then whether or not FxCop is run depends entirely on whether
         the Sonar ruleset exists. -->
    <RunCodeAnalysisOnce>$(SonarRulesetExists)</RunCodeAnalysisOnce>
  </PropertyGroup>

  <!-- We want to override any properties that have been set declaratively in the project -->
  <Target Name="OverrideCodeAnalysisProperties" Condition="$(RunSonarAnalysis) == 'true' AND $(SonarOutputPath) != '' "
              BeforeTargets="RunCodeAnalysis" >

    <Message Condition="$(SonarRulesetExists) != 'true' "
             Importance="normal"
             Text="Skipping FxCop analysis because the Sonar ruleset does not exist. Ruleset: $(SonarRulesetFullName)" />

    <Message Condition="$(SonarRulesetExists) == 'true' "
             Importance="normal"
             Text="Running FxCop analysis using the Sonar ruleset. Ruleset: $(SonarRulesetFullName)" />

    <PropertyGroup>
      <!-- By the time this target is evaluated, the FxCop targets have evaluated the
           $(RunCodeAnalysis) and $(RunCodeAnalysisOnce) properties and used them to 
           set $(RunCodeAnalysisOnThisProject). If we want to stop code analysis from
           running at this point, we need to set $(RunCodeAnalysisOnThisProject). -->
      <RunCodeAnalysisOnThisProject>$(SonarRulesetExists)</RunCodeAnalysisOnThisProject>

      <CodeAnalysisRuleSet>$(SonarRulesetFullName)</CodeAnalysisRuleSet>
      <CodeAnalysisForceOutput>true</CodeAnalysisForceOutput>
      <CodeAnalysisGenerateSuccessFile>true</CodeAnalysisGenerateSuccessFile>
      <CodeAnalysisIgnoreGeneratedCode>true</CodeAnalysisIgnoreGeneratedCode>
    </PropertyGroup>

  </Target>

  <!-- If FxCop is being run then record the FxCop output file as an analysis result -->
  <Target Name="SetFxCopAnalysisResult" Condition=" $(SonarRulesetExists) == 'true' "
                AfterTargets="RunCodeAnalysis" BeforeTargets="WriteSonarProjectData" >
    <ItemGroup>
      <AnalysisResults Include="$(CodeAnalysisLogFile)">
        <Id>FxCop</Id>
      </AnalysisResults>
    </ItemGroup>
  </Target>

  <!-- **************************************************************************** -->
  <!-- End of FxCop section-->
  <!-- **************************************************************************** -->

</Project>